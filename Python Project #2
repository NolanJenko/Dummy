import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
from collections import deque


def degree(graph, vert):
    deg = 0
    for i in graph.edges():
        if vert in i:
            deg += 1
    return deg


def clusteringCoeffecient(graph, vert):
    cc = 0.0
    temp = []
    t = 0
    
    # finds all edges connected to the specified vertice
    for i in graph.edges():
        if vert in i:
            temp += i
            temp.remove(vert)

    for j in temp:
        t+=1
        for i in temp[t:]:
            if (i, j) in graph.edges:
                cc += 1
    if ((len(temp)*(len(temp)-1))/2) != 0:
        return cc/((len(temp)*(len(temp)-1))/2)
    else:
        return 0


def graphCC(graph):
    cc = 0
    size = 1
    for i in graph.nodes():
        size+=1
        cc += clusteringCoeffecient(graph, i)
    return cc/size


def closeness(graph, vert):
    cc = 0
    for i in graph.nodes():
        cc += shortPathDist(graph, vert, i+1)
    return (len(graph)-1)/cc


def averageShortest(graph):
    aver = 0.0
    for i in graph.nodes():
        for j in graph.nodes():
            print(str(j) + " " + str(i))
            aver += shortPathDist(graph,i, j)
    return aver/(len(graph.nodes())*(len(graph.nodes())-1))


# Using breadth first search to find the shortest path between any two given vertices
def shortPathDist(graph, source, target):

    # creating two arrays that are are of size N which is the number of nodes
    dist = [0] * 30
    visited = [False] * 30

    # Making a queue of the node to be visited
    queue = []

    # Mark the source node as
    # visited and enqueue it
    queue.append(source)
    visited[source-1] = True


    while queue:
        s = queue.pop(0)
        for j in graph[s]:
            if visited[(j-1)] is False:
                queue.append(j)
                dist[(j-1)] = dist[s-1]+1
                visited[(j-1)] = True
                if j == target:
                    return dist[j-1]

    return 0

def main():
    # practice graph
    ex = nx.Graph()
    ex.add_edge(1, 2)
    ex.add_edge(1, 3)
    ex.add_edge(1, 4)
    ex.add_edge(2, 3)
    ex.add_edge(3, 4)
    ex.add_edge(1,5)


    file = open(r'C:\Users\Nolan Jenko\Desktop\musae_ENGB_edges.csv', "r")
    next(file, None)

    G_twitch = nx.read_edgelist(file, delimiter=',',create_using= nx.Graph(),nodetype=int)
    G_sub = G_twitch.subgraph(range(1,100))
    c = max(nx.connected_components(G_sub),key = len)

    # Preprocessed data take from the sub graph and the largest connected component of the original data set
    Data = G_sub.subgraph(c).copy()
